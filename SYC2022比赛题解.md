## Day1

> 给定数组 $A$，函数 $T(A)$ 会返回一个新数组，函数 $T$ 如下所示：
>```cpp
>vector <int> T(vector<int> A){
>    vector <int> B;
>    int n=A.size(), i, j, k;
>    for (i=0; i<n; i++){
>        for (j=0; j+i<n; j++){
>            int mx=A[j];
>            for (k=j; k<=i+j; k++) mx=max(mx, A[k]);
>            B.push_back(mx);
>        }
>    }
>    return B;
>}
>```
> 你的任务很简单 —— 求 $T(T(A))$ 的所有元素之和，答案对 $10^9+7$ 取模输出。$n \le 10^5$ 。

设 $x$ 左边第一个大于 $x$ 的位置为 $l_x$，右边第一个大于 $x$ 的位置为 $r_x$，答案只与 $l_x$ 与 $r_x$ 有关。

将 $T(A)$ 按照如下顺序排列，分类讨论每个数对每一行的贡献即可。

![Day1(1)](/pic/Day1(1).png)

注意，边界情况 $l$ 和 $r$ 可能跨行。

> Alice 和 Bob 正在玩游戏，游戏规则如下——
>
>给定一个长度为 $n$ 的字符串，每次操作只能为以下二者之一：
>
>1. 删去一个字符。
>
>2. 将当前字符串打乱，重新排列为此前没有出现过的一个新字符串。
>
>Alice 先手，首先删完字符串的人获胜，两人都绝顶聪明，会按照最优策略行动。
>
>Bob 觉得这游戏对自己很不公平，于是他想知道，假设字符串的所有字符均选自集合 $\{1,2,...,k\}$，总共有多少种字符串能够使自己获胜？
>
>答案对 $19260817$ 取模后输出（这是一个质数）。$n \le 266666$

记字符串的不同排列数为 $cnt$。若 $cnt$ 为偶数，则 Alice 可以自己操作或强行让 Bob 操作，故 Alice 必胜。

若 $cnt$ 为奇数，考虑 $n=3$ 的情况，此时 Alice 必胜。考虑所有 $n$ 为奇数的情况，则此时记第 $i$ 种颜色的出现次数为 $a_i$，则必存在一种颜色出现奇数次，删去这种颜色转化为 $n$ 为偶数，$cnt$ 为奇数，而该情况不能转化为上述的必胜局面。

综上，Bob 必胜当且仅当 $n$ 为偶数且 $cnt$ 为奇数。这等价于将 $n$ 拆分成若干个 popcnt 不同的数，子集卷积即可。

注意，常数项为 $0$，不能使用 $\ln$ 和 $\exp$。

T3 先咕着。

## Day2

>有 $n$ 个随从站成一排，第 $i$ 个随从的攻击力为 $a_i$，血量为 $h_i$。每个随从还会使它左右相邻随从的攻击力提供 $b_i$。
>
>你的攻击力为 $m$，每次你可以选择一只活着的随从进行攻击，使其血量减少 $m$。如果其血量小于等于 $0$，则它死亡，并且它两边的随从会靠在一起成为相邻关系。
>
>在你攻击第 $i$ 个随从时，你不仅会受到 $a_i$ 点伤害，还要额外承受其相邻随从的提高攻击值 $b_{i−1}+b_{i+1}$ 点伤害（如果它们存在）。求你最少受到多少点伤害可以消灭所有随从。$n \leq 400$。

枚举最后一个删的数的位置，区间 dp 即可。

> 给定 $n,m$，求有多少长度为 $2m$ 的序列 $a$ 满足：
>
>$$∀1≤i≤2m,a_i∣n$$
>
>$$\prod^{2m}_{i=1}a_i≤n^m$$
>
>答案对 $998244353$ 取模。

将 $\prod\limits_{i=1}^{m}a_i$ 除到等号右边，转化为求 $\prod\limits_{i=1}^{m}a_i$ 相等的对数，枚举质因数每一项系数容斥计算即可。

>定义对 $k$ 个长度为 $n$ 的序列的归并为：
>
>维护一个空序列 $A$，执行下列操作 $kn$ 次: 选择一个非空序列，将其第一个数取出，放入 $A$ 的末尾。
>
>两个归并不同，当且仅当存在某次操作，选取的序列标号不同。
>
>一个归并被称为是合法的，当且仅当最终序列 $A$ 中不存在一个长度为 $k$ 的子串，使得这个子串中的数为同一个数。
>
>给定 $m$ 个长度为 $n$ 的排列，定义 $f(l,r)$ 表示只考虑 $[l,r]$ 中的排列不同的合法归并方法数，求 $\sum^{m}_{i=1}\sum^m_{j=i+1}f(i,j)$ 模 $998244353$ 的值。
>
>**保证测试数据随机生成。** $1 \leq n,m \leq 30$。

对于每个左端点计算每个右端点的答案。考虑对每个 $i$ 计算作为第一次不合法的方案数。枚举前面的某个数 $j$ 并计算 $j$ 在 $i$ 之前出现连续 $m$ 次的方案数，则当且仅当对于每个序列 $j$ 均在 $i$ 之前出现才会被计算。跨行转移的时候用前面的系数更新即可。每个 $j$ 的期望被计算次数为 $O(1)+O(\dfrac{1}{2})+O(\dfrac{1}{4})...=O(1)$。总时间复杂度为 $O((n+m)nm)$。

## Day3

>有一个随机变量 $z$，初始 $z=0$。
>
>执行 $n$ 次操作：每次操作是从 $0$ 到 $k$ 中以 $p_t$ 的概率选择一个整数 $t$，并令 $z:= z+t$。
>
>求 $\min(z, m)$ 的期望。答案模 $998244353$。

记 $G(x)=\sum_{i=0}^{k}p_ix^i$，则原题即求 $G(x)^m$，求导比较等号两侧系数即可。

> 你要生成一个长度为 $n$ 的数列，有 $m$ 个可行数对，每个可行数对 $(a_i, b_i)$ 表示 $b_i$ 这个数能放在 $a_i$ 这个位置上。已知这 $m$ 个可行数对能生成出的排列数量是奇数，对于每个可行数对，你想知道如果删掉它，剩下的可行数对能生成的排列数量是否还是奇数。

构造 01 矩阵 $A$ 使得 $A_{a_i,b_i}=1$。将 $1$ 改为 $0$ 后变化量即为代数余子式，求伴随矩阵即可。

>世界杯小组赛就要结束了，这是 $\text{Y}$ 国队的生死战，他们只有获得胜利才能出线。
>
>由于这只队伍是一只很迷的队伍，所以对于队中的所有 $n$ 个队员，第 $i$ 个队员这场能够发挥的实力是一个 $\left[0,a_i\right]$ 中的随机实数。不过这只队伍的配合很好，如果最终第 $i$ 个队员发挥出了 $x_i$ 的实力，那么这支队伍的战力就是 $\left(\sum_{i=1}^n x_i\right)^m$ 。现在球队的主教练 $\text{Y}$ 夫希望能够计算出这场比赛他们期望下能够发挥出多少的战力。
>
>为了避免精度误差，请输出答案在模 $998244353$ 下的值。

答案即为

$$\begin{aligned}
    \dfrac{1}{\prod\limits_{i=1}^{n}a_i}\int_{0}^{a_1}\int_{0}^{a_2}...\int_{0}^{a_n}(\sum_{i=1}^{n}x_i)^m\prod_{i=1}^{n}dx_i &= \dfrac{m!}{\prod\limits_{i=1}^{n}a_i}\int_{0}^{a_1}\int_{0}^{a_2}...\int_{0}^{a_n}\sum\limits_{\sum b_i =m}\prod_{i=1}^{n}\dfrac{x_i^{b_i}dx_i}{b_i!} \\ &= m! \sum\limits_{\sum b_i =m}\prod_{i=1}^{n} \dfrac{a_i^{b_i}}{(b_i+1)!}\\
    &= m!\prod_{i=1}^{n}\sum_{j=0}^{+\infin} \dfrac{a_i^jx^j}{(j+1)!}[x^m]
\end{aligned}$$

考虑求后面那个东西，先取 $\ln$ 再 $\exp$。那么要求

$$\begin{aligned}
    \sum_{i=1}^{n}\ln(\sum_{j=0}^{+\infin}\dfrac{a_i^jx^j}{(j+1)!})
\end{aligned}$$

的前 $m$ 项。

记 $G(x)=\ln(\sum_{j=0}^{+\infin}\dfrac{x^j}{(j+1)!})=\sum\limits_{j=0}^{+\infin}g_jx^j$，那么上面那个东西可以化为 

$$\begin{aligned}
    \sum_{i=1}^{n}G(a_ix) &= \sum_{i=1}^{n}\sum\limits_{j=0}^{+\infin}g_ja_i^jx^j \\&= \sum_{j=0}^{+\infin}g_j\sum_{i=1}^{n}a_i^jx^j
\end{aligned}$$

后面那个东西就是 $\sum\limits_{i=1}^{n}\dfrac{1}{1-a_ix}[x^j]$，分治求出这个和式的每一项系数即可。

## Day4

> 定义函数 $F(x)$ 表示 $x$ 的不同质因子数量，例如，$F(6)=2$，$F(8)=1$（$6$ 有质因子 $2,3$，$8$ 只有质因子 $2$）。
>
>给定长度为 $n$ $(1 \le n \le 10^5)$ 的数组 $A=\{A_1,A_2,...,A_n\}$，其中数组内元素均为不超过 $10^7$ 的正整数。
>
>你需要回答 $q$ 次询问，每次询问给定 $L,R$，求 $\sum_{i=L}^{R} \sum_{j=i+1}^{R} F(\gcd(A_i,A_j))$。
>
>其中，$\gcd(a,b)$ 表示正整数 $a,b$ 的最大公约数。

莫队。

>A 国有 $n(1 \le n \le 10^5)$ 个城市，初始条件下两两之间修建道路（道路均为无向边）的代价均为 $0$。
>
>修建道路的代价会不断更新，按照时间先后顺序，总共有 $m(1 \le m \le 10^5)$ 次更新 ——
>
>每次更新由形如 $x_1,x_2,y_1,y_2,w(1 \le x_1 \le x_2 \le n, 1 \le y_1 \le y_2 \le n,-10^6 \le w \le 10^6)$ 的五个参数表示,
>
>其中，对于所有满足 $x_1 \le i \le x_2, y_1 \le j \le y_2$ 的点对 $(i,j)$，连接 $i$ 号城市和 $j$ 号城市的代价会增加 $w$（注意，如果点对 $(i,j),(j,i)$ 均满足条件，这条道路的修建代价会增加 $2w$），在所有更新结束后，询问 —— 在最小化所修道路数量的基础上，能够保证 A 国任意两个城市可以互相到达的最小总代价是多少？
>
>每个测试点有多组数据。

Boruvka 算法，线段树维护最小值和与最小值所在连通块不同的次小值即可。

>Alice 想给 Bob 传递一个长度为 $n$ 的 01 串 $c=c_1c_2....c_n$，因为担心被窃听，因此对信息进行了加密，加密方式如下 ——
>
>Alice 首先选择出 $n$ 个正整数 $a_1,a_2,...a_n$，对于任意 $i$ 均满足 $a_i > \sum_{j=1}^{i-1} a_{j}$，且 $\sum_{i=1}^{n} a_i < q = 2^{64}$。
>
>接下来，Alice 随机生成一个奇数 $r$，构造出数列 $b_1,b_2...b_n$，满足 $b_i \equiv a_i \times r \pmod{q}$。
>
>最后，Alice 将 $b_1,b_2,...b_n$ 以及 $\sum_{i=1}^{n} b_{i}c_{i} \pmod{q}$ 的值发给了 Bob，并声称 Bob 能够根据这些信息还原出原 01 串 $c=c_1c_2....c_n$。
>
> Bob 发现自己并不会还原，于是向你求助。$1 \leq n \leq 63$。

$n \leq 40$，双搜。

$n \ge 40$，枚举 $a_1$，算出 $r$。

## Day5

> 我们定义仙人掌为任何一条边至多在一个简单环内的简单连通图。
>
>对于一棵 $n$ 个点的仙人掌，我们定义 $f(l,r)$ 为只保留编号位于 $[l,r]$ 之间的点的时候，形成的连通块数量。你需要求出下面这个式子：
>
>$$
>\sum_{i=1}^n\sum_{j=i}^n f^k(i,j)
>$$
>
>虽然答案不会很大，但为了让它看起来更像一个计数题，你还是要输出答案对 $10^9+9$ 取模后的值。$k \in \{1,2\}。$

连通块数量等于点数减边数加环数。

二次项暴力展开，现在只考虑计算边数乘环数。

发现每条边和每个环都对应一个区间，将区间按左端点排序，树状数组维护后分类讨论即可。

> 这是一道构造题。
>
> 从前，有两个神奇的数字 $n$ 和 $k$。
>
> 现在，你希望构造一个 $n$ 个点的简单图，其中每个点的度数都至少是 $k$。
>
> 这个问题太过于简单了，于是你还希望图中所有度数为 $k$ 的点均不相邻。
>
> 在满足上述要求的情况下，你还想让总边数最小。

注意到一定存在一种最优方案满足只有度数为 $k$ 和 $k+1$ 的点，计算出上界然后构造即可。

构造的存在性由 Erdős–Gallai 定理 可得到。

> 序列 $S$ 可简单图化当且仅当对 $\forall k \in [1,n]$，有 $\sum_{i=1}^k d_i \leq k(k-1)+ \sum_{i=k+1}^n \min(d_i,k)$

以及构造可由 Havel–Hakimi 算法 得到。

>对于一个 $B$ 进制数 $x=\sum x_iB^i$，我们定义它的数根 $r(x)$ 如下：
>
>$$
>r(x)=\begin{cases}x&x<B\\\sum\limits_{i=1}x_i&x\ge B\end{cases}
>$$
>
>如：$r(abcd_{16})=r(2e_{16})=r(10_{16})=1_{16}$。
>
>现在你有一个长度为 $n$ 的 $B$ 进制串 $s$，每次给定一个集合 $A$ 和一个数 $x$，你需要回答有多少个 $s[l\ldots r]$ 可以通过将至多一个字符更改为 $A$ 中的元素使得数根为 $x$。

注意到 $r(x)=x \bmod B-1$。对于 $r(x)=0$ 特判。

我们想对于 $k \in [0,B-1)$，计算出和等于 $k$ 的区间有哪些不同的元素。枚举 $r$，记前缀和为 $s_i$，则对于每个 $s_l$，统计 $[l+1,r]$ 中出现的元素并贡献到 $s_r-s_l$ 中。注意到每个值只要维护最早出现的位置即可。

然后做 FMT，对于每个询问枚举每个值暴力判断即可。

## Day6
> 小 A 打算出去旅行，他决定在 $n$ 个城市中来规划旅行路线，这 $n$ 个城市由 $m$ 条双向道路连接，由于隔离政策各不相同的原因，对于双向道路 $(x_i,y_i)$，$x_i\to y_i$ 的长度为 $a_i$，$y_i\to x_i$ 的长度为 $b_i$，小 A 居住的城市为 $1$ 号城市。
>
> 现在小 A 想要从 $1$ 号城市出发，经过一些城市，最后回到 $1$ 号城市，并且由于重复的风景总是乏味的，因此要求每条双向道路至多被经过一次，为了节省时间，他决定在所有的可能路线中选择最短的那一条路线。
>
>由于小 A 正忙，所以他拜托你帮他计算一下最短的可能路线的长度。
>
>注意，小 A 并不要求经过所有的城市，但至少经过除了 $1$ 号城市外的一个城市。

维护到每个与 $1$ 直接相连的节点的最短路和与最短路经过的第一个节点不同的次短路即可。

>考虑下面这个随机数生成器。该生成器的当前状态用 state 表示，它可以是 $0$ 到 $2^{32}-1$（含）的任何整数。
>
>```
>Function random (range):
>    state := (state * 1664525 + 1013904223) mod 2^32;
>    return (state * range) div 2^32;
>```
>
>这里，mod 和 div 是取余数和整数除法的操作。
>
>为了随机排列一个数组，可以使用 shuffle 函数。

>```
>Function shuffle (array):
>    n := length of array;
>    for i := 0, 1, 2, ..., n - 1:
>        j := random (i + 1);
>        array[i] <-> array[j];
>    return array;
>```
>
>这里，操作 "$x\leftrightarrow y$" 交换了元素 $x$ 和 $y$；如果它们是数组中的同一个元素，什么都不会发生。
>
>现在有一个未知的整数种子 $0\sim 2^{32}-1$（含）。之后，他运行了以下程序。
>
>```
>state := seed;
>n := 10000;
>array := [1, 2, ..., n];
>array := shuffle (array);
>array := shuffle (array);
>```
>
>虽然不知道随机种子，但是经过两次随机以后的数组我们已经知道了。
>
>在程序末尾加上下面一行，请问数组的内容会是什么？
>
>```
>array := shuffle (array)
>```

考虑如何 $O(1)$ 检查一个 seed。只要看后一百个数在该 seed 的作用下有多少个数移动到正确位置即可。

现在考虑枚举 $n$ 第一次操作后的位置，可以得到关于 seed 的两个方程。方程形如 $f_1x+g_1 \bmod 2^{32} \in [l_1,r_1]$。

注意到暴力枚举复杂度是 $r_1-l_1+1 = O(\dfrac{2^{32}}{n})$ 的，而同时满足两个方程的解只有 $O(\dfrac{2^{32}}{n^2})$ 个。于是我们考虑对区间 $[l_1,r_1]$ 进行分治，只向有解的区间内递归。

如何判断区间 $[l_1,r_1]$ 内是否有解？注意到有解等价于存在 $x \in [l_1,r_1]$，使 $\lfloor \dfrac{f_1x+g_1-r_1}{2^{32}} \rfloor \neq \lfloor \dfrac{f_1x+g_1-l_1}{2^{32}} \rfloor$，而 $\lfloor \dfrac{f_1x+g_1-l_1}{2^{32}} \rfloor - \lfloor \dfrac{f_1x+g_1-r_1}{2^{32}} \rfloor = \{0,1\}$，只需要计算 $\sum\limits_{x=l_1}^{r_1} \lfloor \dfrac{f_1x+g_1-t}{2^{32}} \rfloor$ 即可，使用类欧。

>众所周知，单位根可以处理一些循环卷积的问题，现在 ysgh 算出了一个结果，即形如 $\sum_{i=0}^{n-1} a_i w_n^i$。（$w_n^i$ 表示 $n$ 次本原单位根的 $i$ 次方）。
>
>但他发现不同的表现方式往往可以表现出一样的数。
>
>比如 $3+2 w_{2}^{1}=1$。
>
>ysgh 想让单位根的最大次数变得尽可能小，现在他将结果交给你，请你计算出一个新的形式 $\sum_{i=0}^{k} b_i w_n^i$ 等于原数且 $k$ 最小，其中 $b_i$ 是整数。只需输出任意一组合法的解即可。为了方便，本题所有数是基于模 $998244353$ 意义下的，输出时也对 $998244353$ 取模。也就是说，这意味着如果 $b_k \bmod 998244353=0$，那么这一项是没必要的。
>
>回忆一下，多项式 $x^n-1=0$ 的 $n$ 个根称为 $n$ 次单位根。

对分圆多项式取模即可。

## Day7
> 对于整数序列 $(a_1,\cdots,a_n)$，和 $1\sim n$ 的排列 $(p_1,\cdots,p_n)$，称 $(a_1,\cdots,a_n)$ 符合 $(p_1,\cdots,p_n)$ 当且仅当：
>
>$(a_1,\cdots,a_n)$ 中任意两个数字互不相同；
将 $(a_1,\cdots,a_n)$ 从小到大排序后，将会得到 $(a_{p_1},\cdots,a_{p_n})$。
>
>现在给出 $1\sim n$ 的排列 $(p_1,\cdots,p_n)$ 和序列 $(h_1,\cdots,h_m)$，请你求出有几个 $(h_1,\cdots,h_m)$ 的子串符合排列 $(p_1,\cdots,p_n)$。

将相等的定义修改为向左第一个大于它的数和向右第一个大于它的数与它的距离，跑 kmp 即可。

> 2021 年，香港中文大学（深圳）举办中国队训练（CTT）。今年有参赛者参加 CTT，赛程安排有四个单项比赛。在每项比赛中，每位参赛者都获得一个分数：第 $i$ 名选手在第 $j$ 天竞赛中的成绩表示为 $w_{i,j}(1\le j\le 4)$。$w_{i,j}$ 是范围 $[1,300]$ 内的整数并保证是一个 $5$ 的倍数。
>
> 完成所有比赛后，竞赛委员会将公布四场比赛的非负实数权重 $a_1,a_2,a_3,a_4$，保证 $\sum_{i=1}^4 a_i=1$。然后，参赛者将根据加权分数进行排名：第 $i$ 名选手的加权分数等于 $\sum_{j=1}^{4} a_jw_{i,j}$，第 $i$ 名选手的排名等于其他分数比他高的选手个数加一。
>
> 现在，所有比赛都结束了，但比赛权重尚未公布。您的任务是确定每个参赛者的最佳排名，即对于第 $i$ 名参赛者，您应该确定实数权重使得他的排名尽可能小，注意权重需要非负，且和为 $1$。$n \leq 50$。

我们可以通过调整使最优方案中有四个人相等，枚举这四个人即可。

> <strong>W<font color="red">ZYYN</font></strong> 是个老数数大师了。
>
> 对于一张无自环的无向图 $G$，<strong>W<font color="red">ZYYN</font></strong> 定义集合 $T(G)$ 表示 $G$ 的所有不同的生成树形成的集合。两棵生成树是不同的当且仅当它们使用的边集不同。
>
><strong>W<font color="red">ZYYN</font></strong> 搞出了一张 $n$ 个点无自环的无向图 $G_1$，他数出了所有生成树，他想让你也数一数。为了检验你是不是真的数出了每棵树，你需要告诉他任意一对点 $(i,j)$ 之间的边总共出现了多少次。
>
>形式化地，对于所有 $i,j$ 满足 $j>i$，要计算：
>
>$$\sum_{I\in T(G_1)} [(i,j)\in I]$$
>
>答案可能很大，输出对 $P$ 取模的后的结果。
>
>对于 $T=1$ 的数据，只需要输出 $\left(\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^{n} (i \oplus j)ans_{i,j}\right) \bmod P$。

神秘的任意模数 $O(n^3+n^2s\log s)$ 求伴随矩阵做法，还能求逆。有空再说。

## Day8
> 你有 $N$ 天时间完成一项作业。这项作业有 $R$ 个步骤，每个步骤必须在前一个步骤之后完成。第 $i$ 天结束时，学校将对作业前 $p_i$ 个步骤的完成情况进行一次检查（若 $p_i=0$，表示检查作业的人也摆烂了，翘了班），因此你需要在此之前完成这些步骤。你想知道你有多少种写作业的方案，其中两个方案不同当且仅当某个步骤被完成的天数不同。由于你想摆烂，你并不需要完成作业的所有步骤。由于方案数可能很大，请输出答案对 $10^9+7$ 取模的结果。

记 $F_{i,j}$ 表示前 $i$ 天完成 $j$ 项作业的方案数。则有 $F_{i,j}=\sum_{k=0}^{j}F_{i-1,k}-\sum_{k=0}^{p_i}F_{i-1,k}$。

考虑记 $F_i=\sum_{j=0}^{+\infin}f_{i,j}x^j$，则 $F_i=\dfrac{1}{1-x}F_{i-1}-\dfrac{1}{1-x}[x^{p_i}]\dfrac{1}{1-x}F_{i-1}$

展开后不同的 $[x^{p_i}]$ 项仅有 $O(n)$ 项，转移过程中维护即可，复杂度 $O(n^2)$。

>你将要规划一条街道。这条街道可以看作一条数轴，其中有 $m$ 个电线杆，其中第 $i$ 个位于从原点出发往正方向 $i$ 米处。
>
>你要往电线杆上安装 $n$ 个设备，比如基站、摄像头等。有些设备放在某些地点效益更高，比如基站最好放在人流量大的地方，因此设备放在某个地方将产生依赖于设备和地点的效益值。具体地说，将第 $i$ 号设备放在第 $j$ 个电线杆处能产生 $p_{i,j}$ 的效益值。有 $k$ 对设备之间需要用线路连接，因此这些设备所在的电线杆之间每间隔一米就会产生 $-C$ 的效益值。你想知道总的效益值最大是多少。

最小割。将每个点拆成一条长为 $m$ 的链，对于 $(a_i,b_i)$，将他们的对应点间连边权为 $C$ 的双向边。

T3 咕。

## Day9
> 你站在一个 $n\times m$ 的棋盘上，其中第 $x$ 行第 $y$ 列的格子坐标为 $(x,y)$。（从 $1$ 开始标号）
>
>每一个格子里面有一个宝箱，其中 $(1,1)$ 这个格子中的宝箱中藏着宝物，而其余的每一个宝箱都藏着一把开启另一个宝箱的钥匙。你在拿到钥匙后就已经知道了这个钥匙可以开启哪一个宝箱。
>
>你现在站在 $(1,1)$，手里拿着一把钥匙。为了拿到宝物，你必须顺次开启若干个宝箱，最后回到 $(1,1)$ 这个格子拿到宝物。
>
>如果你现在站在 $(x_1,y_1)$，而你想到达 $(x_2,y_2)$ 这个点，那么你走过的距离就是 $|x_1-x_2|+|y_1-y_2|$，也就是曼哈顿距离。
>
>现在你想知道，你最多需要走多远的距离才能拿到宝物。构造一组方案。

每条网格线所造成的贡献是其左右两边格子数的较小值。若某条靠近中线的网格线取到上界，则远离中线的网格线必然取到上界，则只要考虑中线即可。

奇数可取到上界，偶数会比上界小。

> 有一个 $n\times m$ 的网格，行和列均从 $0$ 标号。
>
> 现在你想遍历这个网格。如果当前位于 $(i,j)$，下一步可以到达 $((i+1)\%n,j)$ 或 $(i,(j+1)\%m)$。
>
> 你需要在每一个网格里填入向下或向右的箭头，表示下一步的方向。
>
> 现在你想知道，有多少种填入箭头的方案，使得可以从任意一个格子出发遍历整张图。

如果 $(i,j)$ 向下，那么 $(i+1,j-1)$ 也一定向下，若 $(i+1,j-1)$ 向右，那么 $(i,j)$ 向右。可以得到每条斜线上方向相同。

先考虑 $n=m$ 的情况，可以发现可以遍历整张图当且仅当某条对角线上所有点均可达。只需要判断主对角线即可。

对于 $n \neq m$ 的情况，分成边长为 $(n,m)$ 的正方形即可。

>对于两个字符串 $s,t$，我们设 $cnt_{s,t}$ 为 $s$ 中 $t$ 出现的次数。
>
>对于一个字符串 $s$，我们定义它的一个子串 $t$ 是重要的，若对任意以 $t$ 为子串的字符串 $t'$，都有 $cnt_{s,t'}< cnt_{s,t}$。
>
>现在有一个长度为 $n$ 的字符串 $s$。你需要回答它的每一个前缀有多少个重要的子串。

一个串是重要的，当且仅当它是等价类中最长的字符串并且它有至少两个后继，或它是整串的后缀并且它至少有一个后继，或它代表整串。

考虑在构建 SAM 的过程中动态维护，需要支持插入一个节点，添加一个节点至某个节点的儿子，给某个点打标记，查询根到某个点的无标记节点数。

注意到并不需要用 LCT，插入节点相当于子树权值加 1，添加一个节点父亲权值可能减 1。于是把所有操作离线下来，树状数组维护即可。

## Day10
>小F在登山。山峰可以看作二维平面上的一条折线，由 $i(1 \leq i \leq n) $ 号节点 $(i,h_i) $ 和连接相邻节点之间的线段组成。保证 $h_i $ 构成 $1,\cdots,n $ 的排列。
>
>为了确定自己的位置，小 F 需要购买高度计。山上共有 $k $ 种高度计可供购买，遗憾的是这些高度计的量程可能不够大，无法在太高或太低的地方使用。其中 $i $ 号高度计仅在 $p_i $ 号节点销售，售价为 $c_i $，只能在高度范围 $[a_i,b_i] $ 内使用。需要注意的是，当离开此范围后，已购买的高度计并不会损坏，当重新进入有效范围后可以继续使用。
>
>为了安全起见，小F需要确保旅程中任意时刻都有至少一个高度计正在生效。为了观赏全部景观，小F想要经过每个节点至少一次。小F想知道，如果他从 $p_i $ 号节点购买 $i $ 号高度计开始登山，他至少需要花费多少钱才能走遍所有节点（如果可能的话）？$n,k \leq 2000$。

确定一个状态需要知道当前所在位置以及所购买的高度计高度的并。我们可以在需要到达一个高度时再买对应的高度计，因此高度的并是一个大区间。

记 $f_{a,b}$ 表示取到值域区间左端点的高度计编号为 $a$，取到区间右端点的高度计编号为 $b$，走完整个区间还需要的最小钱数。

注意到根据 $a,b$ 我们可以确定可以下一个高度计的可选区间。考虑如下三种情况：

![Day10](/pic/Day10.png)

对于第 3 种情况，要求购买的高度计在可选区间内。

对于第 1 种情况，要求购买的高度计在可选区间内，并且其高度小于 $a$ 的高度。我们将 $a_i$ 从小到大排序然后转移即可。

对于第 2 种情况同理。

注意，可能会有不合法的转移，但这些转移都不优于合法转移。使用线段树维护上面三种转移即可。

